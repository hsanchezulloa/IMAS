
task_communication_loss_extractor:
  description: >
    You MUST do exactly these steps:
    Step 1) Call Communication_Loss_Detector
    Step 2) Return EXACTLY the tool output.
    Rules:
      - Do NOT add keys
      - Do NOT remove keys
      - Do NOT reformat
      - Do NOT summarize
      - Do NOT explain
  expected_output: >
    The output from the Communication_Loss_Detector tool. DO NOT MODIFY THE OUTPUT.
  agent: communication_loss_extractor

task_extractor:
  description: >
    Based on the information inside the input file """ {{report_priority}} """, identify in which nodes satellites need to perform their tasks. ONLY TAKE INTO ACCOUNT INFORMATION FROM THE SATELLITES KEY
  expected_output: >
    A Python list containing all the node IDs where satellites need to perform their tasks. ONLY THE LIST NO MORE INFORMATION
  agent: extractor

task_planner:
  description: >
    YOU MUST OUTPUT ONLY RAW JSON.
    NO TEXT. NO EXPLANATIONS. NO MARKDOWN.
    IF YOU OUTPUT ANYTHING EXCEPT JSON, YOU FAILED.

    REQUIRED OUTPUT FORMAT (EXACT):

    {
      "assignments": [
        {
          "id": "<satellite_id>",
          "goal": "<target_node>",
          "location": "<physical_location>",
          "communication_window": <value_from_satellite_json>
        }
      ]
    }

    OUTPUT RULES:
    - JSON ONLY
    - Must start with { and end with }
    - No comments
    - No trailing text
    - No code blocks
    - No markdown
    - No explanations

    --------------------------------------------------
    FOLLOW THE RULES BELOW EXACTLY
    --------------------------------------------------

    DEFINITIONS (STRICT):
      - goal: target node assigned for observation.
      - coverage: a satellite can observe a node ONLY if it appears in its covered_nodes list.
      - physical location: the single node where the satellite is positioned (chosen from coverage list).
      - communication_window: timing value exactly as provided in satellite_json.

      NOTE:
      - A satellite does NOT need to be physically located at its goal node. But the goal needs to be in the coverage list
      - goal and location may differ.

    INPUTS (AUTHORITATIVE):
      1) Hazard & Operational Constraints Report:
        """ {{report_hazard_constraints}} """

      2) Satellite Registry (JSON):
        """ {{satellite_json}} """

      3) Target Nodes (Mission Priorities):
        """ {{context.task_extractor}} """

      4) Communication-Loss Nodes (STRICT AVOIDANCE FOR LOCATIONS):
        """ {{context.task_communication_loss_extractor}} """

    PLANNING RULES (MANDATORY):

      1) Coverage Validation:
        - Compute reachable targets per satellite:
          reachable = targets âˆ© satellite.covered_nodes
        - A satellite MAY ONLY be assigned a goal from its reachable set.
      
      2) Hazard & Operational Constraints (PRIORITY STEP):
        - Apply ALL satellite-related constraints from the report_hazard_constraints report.
        - Operational constraints ALWAYS take priority.

        - If a goal node has thermal anomalies:
            - Only satellites with communication_window <= 5 are ALLOWED
            - communication_window MUST match satellite_json exactly
            - All satellites with window >5 are FORBIDDEN

        - If any hazard rule forbids operation:
            - That target MUST be removed from candidate pool
      
      3) One-to-One Assignment:
        - EACH target node MUST be assigned to EXACTLY ONE satellite.
        - NO target node may appear more than once.
        - Satellites may only receive ONE goal unless explicitly stated otherwise.

      4) Communication Constraints:
        - physical location MUST NOT be in communication-loss nodes.
        - goal node MAY be in communication-loss nodes (allowed).

      5) Physical Location Selection:
        - Each used satellite MUST have exactly ONE location.
        - location MUST be:
            - from satellite.covered_nodes
            - NOT in communication-loss nodes

      6) Final Validation (REQUIRED BEFORE OUTPUT):
        - All targets assigned exactly once
        - All satellite IDs exist in satellite_json
        - All goals are inside assigned satellite coverage
        - All locations are valid and non-loss nodes
        - communication_window matches satellite_json exactly

    FORBIDDEN:
      - Inventing satellites, nodes, hazards, or windows
      - Guessing missing data
      - Skipping any constraint
    CRITICAL OUTPUT RULES:
      - You MUST return ONLY valid JSON.
      - Do NOT include explanations.
      - Do NOT include markdown.
      - Do NOT include LaTeX.
      - Do NOT include tables.
      - Do NOT include bullet points.
      - Output MUST start with { and end with }
      - Any extra text INVALIDATES the answer.
    FAILURE CONDITIONS:
      - If output is not pure JSON -> response is INVALID.
      - INVALID responses are considered mission failure.
  expected_output: >
    You MUST return EXACTLY this structure:
    {
      "assignments": [
        {
          "id": "<satellite_id>",
          "goal": "<target_node>",
          "location": "<physical_location>",
          "communication_window": <value_from_satellite_json>
        }
      ]
    }

    STRICT:
      - No text before or after JSON
      - No markdown
      - No comments
      - No explanations
  agent: planner


task_image_capture:
  description: >
    1. Parse the 'satellite' key from the provided JSON file: """ {report_priority} """.
    2. Identify all targets across high, medium, and low priority levels.
    3. For each unique mission type (e.g., panoramic terrain capture, thermal identification), generate a distinct 5-step instruction set.
    4. Ensure instructions account for specific terrain types mentioned, such as 'crater' or 'icy' nodes, including specifying the appropriate time window for image acquisition.
  expected_output: >
    A formatted technical manual containing 5-step procedural guides for each satellite mission found in the JSON. Each guide must include sensor initialization, positioning, capture sequence, data validation, and transmission steps.
  agent: image_capture

