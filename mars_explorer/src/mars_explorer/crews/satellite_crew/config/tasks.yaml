# task_communication_loss_extractor:
#   description: >
#     Your ONLY job is to take the entire GRAPHML path  """ {{graph_path}} """
#     and pass it UNCHANGED to the 'Communication_Loss_Detector' tool in the 'args_schema' argument.
    
#     Do NOT try to extract nodes or terrains yourself. 
#     Do NOT summarize. 
#     Pass the entire GRAPHML path exactly as it is: """ {{graph_path}} """
#   expected_output: >
#     The output from the "Communication_Loss_Detector" tool. DO NOT MODIFY THE OUTPUT.
#   agent: communication_loss_extractor

# task_communication_loss_extractor:
#   description: >
#     Your ONLY job is to take the entire GRAPHML path """ {{graph_path}} """
#     and pass it UNCHANGED to the 'Communication_Loss_Detector' tool
#     in the 'args_schema' argument.

#     Do NOT try to extract nodes or terrains.
#     Do NOT summarize.
#     Pass the entire GRAPHML path exactly as it is: """ {{graph_path}} """
#   expected_output: >
#     The output from the "Communication_Loss_Detector" tool. DO NOT MODIFY THE OUTPUT.
#   agent: communication_loss_extractor

task_communication_loss_extractor:
  description: >
    You MUST do exactly these steps:
    Step 1) Call Communication_Loss_Detector
    Step 2) Return EXACTLY the tool output.
    Rules:
      - Do NOT add keys
      - Do NOT remove keys
      - Do NOT reformat
      - Do NOT summarize
      - Do NOT explain
  expected_output: >
    The output from the Communication_Loss_Detector tool. DO NOT MODIFY THE OUTPUT.
  agent: communication_loss_extractor

task_extractor:
  description: >
    Based on the information inside the input file """ {{report_priority}} """, identify in which nodes satellites need to perform their tasks. ONLY TAKE INTO ACCOUNT INFORMATION FROM THE SATELLITES KEY
  expected_output: >
    A Python list containing all the node IDs where satellites need to perform their tasks. ONLY THE LIST NO MORE INFORMATION
  agent: extractor

# task_planner:
#   description: >
#     1. Receive three inputs: the Satellite Registry JSON (containing satellite IDs and locations and communication_window)  """ {{satellite_json}} """ , the list of target nodes (derived from the report_priority) """ {{target_nodes}} """ and the nodes where the satellite CANNOT go as there is communication loss """ {{communication_loss}} """.
#     2. Analyze the 'location' array for each satellite to identify which nodes it currently covers.
#     3. For each Target Node, assign it to a satellite that lists that node in its location data.
#     4. Ensure strict assignment: each goal/node must be assigned to only one satellite, even if multiple satellites cover the same node.
#     5. Filter out satellites that have no assigned goals for the final output.
#   expected_output: >
#     A JSON array of objects, where each object contains the 'id' of the satellite, 
#     the specific 'goal' (target node) assigned to it, and the 'location' 
#     chosen from the context for that assignment, return only ONE node taking into account that it CANNOT be one from the list """ {{communication_loss}} """.
#   agent: planner

# task_planner:
#   description: >
#     1. Receive four inputs: the report hazard constraint """ {{report_hazard_constraints}} """, the Satellite Registry JSON (containing satellite IDs and locations and communication_window)  """ {{satellite_json}} """, the list of target nodes (derived from the report_priority) """ {{target_nodes}} """ and the nodes where the satellite CANNOT go as there is communication loss """ {{communication_loss}} """.
#     2. Analyze the 'location' array for each satellite to identify which nodes it currently covers.
#     3. For each Target Node, assign it to a satellite that lists that node in its location data. TAKE INTO ACCOUNT THE CONSTRAINTS FROM THE SATELLITE SECTION IN THE """ {{report_hazard_constraints}} """ FILE
#     4. Ensure strict assignment: each goal/node must be assigned to only one satellite, even if multiple satellites cover the same node.
#     5. Filter out satellites that have no assigned goals for the final output.
#     6. Assign one final position for each satellite, which must belong to the location list from """ {{satellite_json}} """. 
#   expected_output: >
#     A JSON array of objects, where each object contains the 'id' of the satellite, 
#     the specific 'goal' (target node) assigned to it, the 'location' 
#     chosen from the context for that assignment, return only ONE node taking into account that it CANNOT be one from the list """ {{communication_loss}} """, 'communication_window' assign a number saying WHEN that satellite has to communicate with the base, if there is no need of communciation assign zero to that.
#   agent: planner

# task_planner:
#   description: >
#     You are responsible for assigning target nodes to satellites in a safe, constrained, and conflict-free manner.
    
#     Distinction between Location and Goal: A satellite's 'location' is its physical position in orbit. A satellite's 'goal' is the target node it is assigned to observe. A satellite does NOT need to be physically located at the target node to cover it, as long as that target node is within its allowed coverage range.

#     1. You will receive four inputs:
#       - Hazard and operational constraints report: """ {{report_hazard_constraints}} """
#       - Satellite Registry JSON, containing satellite IDs, their allowed locations (node lists), and their communication windows: """ {{satellite_json}} """
#       - Target nodes to be covered, derived from mission priorities: """ {{context.task_extractor}} """
#       - Nodes that must be strictly avoided due to communication loss: """ {{context.task_communication_loss_extractor}} """

#     2. For each satellite, analyze its 'location' data to determine which nodes are within its REACH for observation.

#     3. For each target node:
#       - Assign it to exactly one satellite whose location list includes that node.
#       - Enforce all relevant constraints described in the Satellite section of """ {{report_hazard_constraints}} """ are taken into account when assigning the satellite as THEY HAVE TO HAVE A PROPER COMMUNICATION WINDOW IN THERMAL ANOMALIES NODES.

#     4. Ensure all target nodes are assigned:
#       - Each target node must be assigned to only one satellite.
      
#     5. For each satellite included in the final plan:
#       - Select exactly ONE final operating location (physical position).
#       - The selected location MUST be chosen from that satellite's allowed 'location' list in """ {{satellite_json}} """.
#       - The selected location MUST NOT appear in """ {{context.task_communication_loss_extractor}} """ , BUT THE GOAL CAN APPEAR IN  """ {{context.task_communication_loss_extractor}} """.
#       - The 'goal' (target node) and 'location' (physical node) may be different.

#     6. Assign a communication schedule:
#       - Specify WHEN the satellite can communicate with the base. This is done by taking into account the operational constrains mentioned for satellites in """ {{report_hazard_constraints}} """.

#     Follow all constraints strictly. Do not invent satellites, nodes, or capabilities.
#   expected_output: >
#     A JSON array of objects. Each object MUST contain:
#       - 'id': the satellite identifier
#       - 'goal': the assigned target node
#       - 'location': the selected final node for that satellite
#       - 'communication_window': a numeric value indicating the communication timing 
#     Return only raw JSON. Do not include markdown code blocks, backticks, or any introductory text. Start your response with '{' and end with '}'.
#   agent: planner

# task_planner:
#   description: >
#     You are responsible for assigning target nodes to satellites in a safe, constrained, and conflict-free manner.

#     IMPORTANT DEFINITIONS:
#       Goal: The mission target node assigned to the satellite for observation.
#       - A satellite does NOT need to be physically located at its goal node as long as the node is within its coverage range.

#     Inputs:
#       1. Hazard & Operational Constraints Report:
#         """ {{report_hazard_constraints}} """

#       2. Satellite Registry (JSON):
#         Contains satellite IDs, covered nodes, and communication windows.
#         """ {{satellite_json}} """

#       3. Target Nodes (Mission Priorities):
#         """ {{context.task_extractor}} """

#       4. Communication Loss Nodes (STRICT AVOIDANCE):
#         """ {{context.task_communication_loss_extractor}} """

#     Planning Rules:

#       1. Coverage Analysis:
#         - For each satellite, analyze its covered nodes.
#         - Determine which target nodes each satellite can observe (REACH).

#       2. Goal Assignment:
#         - Each target node MUST be assigned to EXACTLY ONE satellite.
#         - The assigned satellite MUST be capable of observing that node.
#         - Apply ALL constraints from the satellite section of the hazard report.
#         - Satellites assigned to nodes affected by thermal anomalies MUST have valid communication windows.

#       3. Completeness & Uniqueness:
#         - ALL target nodes must be assigned.
#         - No target node may be assigned to more than one satellite.

#       4. Final Location Selection:
#         - Each satellite used MUST have exactly ONE final physical location.
#         - Location MUST come from its allowed covered list.
#         - Location MUST NOT appear in communication-loss nodes.
#         - The goal node MAY appear in communication-loss nodes.
#         - Goal and location may be DIFFERENT.

#     Strict Requirements:
#       - Follow all constraints without exception.
#       - Do NOT invent satellites, nodes, windows, or capabilities.
#       - Use ONLY provided data.

#   expected_output: >
#     Return a JSON array of objects. Each object MUST contain:
#       - id: satellite identifier
#       - goal: assigned target node
#       - location: selected physical location
#       - communication_window: numeric communication timing for each satellite indicated in the satellite_json

#     Output format rules:
#       - Return ONLY raw JSON
#       - No markdown
#       - No explanations
#       - Must start with '{' and end with '}'

#   agent: planner

task_planner:
  description: >
    You are responsible for assigning mission target nodes to satellites
    in a safe, constrained, and conflict-free manner.

    DEFINITIONS (STRICT):
      - goal: target node assigned for observation.
      - coverage: a satellite can observe a node ONLY if it appears in its covered_nodes list.
      - physical location: the single node where the satellite is positioned (chosen from coverage list).
      - communication_window: timing value exactly as provided in satellite_json.

      NOTE:
      - A satellite does NOT need to be physically located at its goal node. But the goal needs to be in the coverage list
      - goal and location may differ.

    INPUTS (AUTHORITATIVE):
      1) Hazard & Operational Constraints Report:
        """ {{report_hazard_constraints}} """

      2) Satellite Registry (JSON):
        """ {{satellite_json}} """

      3) Target Nodes (Mission Priorities):
        """ {{context.task_extractor}} """

      4) Communication-Loss Nodes (STRICT AVOIDANCE FOR LOCATIONS):
        """ {{context.task_communication_loss_extractor}} """

    PLANNING RULES (MANDATORY):

      1) Coverage Validation:
        - Compute reachable targets per satellite:
          reachable = targets âˆ© satellite.covered_nodes
        - A satellite MAY ONLY be assigned a goal from its reachable set.
      
      2) Hazard & Operational Constraints (PRIORITY STEP):
        - Apply ALL satellite-related constraints from the report_hazard_constraints report.
        - Operational constraints ALWAYS take priority.

        - If a goal node has thermal anomalies:
            - Only satellites with communication_window <= 5 are ALLOWED
            - communication_window MUST match satellite_json exactly
            - All satellites with window >5 are FORBIDDEN

        - If any hazard rule forbids operation:
            - That target MUST be removed from candidate pool
      
      3) One-to-One Assignment:
        - EACH target node MUST be assigned to EXACTLY ONE satellite.
        - NO target node may appear more than once.
        - Satellites may only receive ONE goal unless explicitly stated otherwise.

      4) Communication Constraints:
        - physical location MUST NOT be in communication-loss nodes.
        - goal node MAY be in communication-loss nodes (allowed).

      5) Physical Location Selection:
        - Each used satellite MUST have exactly ONE location.
        - location MUST be:
            - from satellite.covered_nodes
            - NOT in communication-loss nodes

      6) Final Validation (REQUIRED BEFORE OUTPUT):
        - All targets assigned exactly once
        - All satellite IDs exist in satellite_json
        - All goals are inside assigned satellite coverage
        - All locations are valid and non-loss nodes
        - communication_window matches satellite_json exactly

    FORBIDDEN:
      - Inventing satellites, nodes, hazards, or windows
      - Guessing missing data
      - Skipping any constraint
    CRITICAL OUTPUT RULES:
      - You MUST return ONLY valid JSON.
      - Do NOT include explanations.
      - Do NOT include markdown.
      - Do NOT include LaTeX.
      - Do NOT include tables.
      - Do NOT include bullet points.
      - Output MUST start with { and end with }
      - Any extra text INVALIDATES the answer.
    FAILURE CONDITIONS:
      - If output is not pure JSON -> response is INVALID.
      - INVALID responses are considered mission failure.
  expected_output: >
    You MUST return EXACTLY this structure:
    {
      "assignments": [
        {
          "id": "<satellite_id>",
          "goal": "<target_node>",
          "location": "<physical_location>",
          "communication_window": <value_from_satellite_json>
        }
      ]
    }

    STRICT:
      - No text before or after JSON
      - No markdown
      - No comments
      - No explanations
  agent: planner


task_image_capture:
  description: >
    1. Parse the 'satellite' key from the provided JSON file: """ {report_priority} """.
    2. Identify all targets across high, medium, and low priority levels.
    3. For each unique mission type (e.g., panoramic terrain capture, thermal identification), generate a distinct 5-step instruction set.
    4. Ensure instructions account for specific terrain types mentioned, such as 'crater' or 'icy' nodes, including specifying the appropriate time window for image acquisition.
  expected_output: >
    A formatted technical manual containing 5-step procedural guides for each satellite mission found in the JSON. Each guide must include sensor initialization, positioning, capture sequence, data validation, and transmission steps.
  agent: image_capture

